/* generated by 'bin/methodTemplateGenerate.js' */
import {getType, hasOwnProperty} from '../utils';

enum BasicType {
    String = 'String',
    Number = 'Number',
    Boolean = 'Boolean',
    Null = 'Null',
    Undefined = 'Undefined',
    BigInt = 'BigInt'
}

enum ReferenceType {
    // Symbol 基础类型，这里当作引用类型处理
    Symbol = 'Symbol',
    Object = 'Object',
    Array = 'Array',
    Function = 'Function',
    RegExp = 'RegExp',
    Date = 'Date',
    Map = 'Map',
    Set = 'Set',
    HtmlElement = 'HtmlElement'
}

type TMap = undefined | null | WeakMap<any, any>;
type ReturnTarget = object | any[];

export function cloneDeep(target: any, map: TMap = new WeakMap()): ReturnType<typeof target> {
    const type: string = getType(target);
    if (type in BasicType) {
        return target;
    }

    switch (type) {
        case ReferenceType.Date:
            return new Date(target);

        case ReferenceType.RegExp:
            return new RegExp(target.source, target.flags);

        case ReferenceType.HtmlElement:
            return target.cloneNode(true);

        case ReferenceType.Function:
            const stringFunction = target.toString();
            return new Function('return' + stringFunction)();

        case ReferenceType.Map:
            const newMap = new Map();
            target.forEach((value: any, key: any) => {
                newMap.set(cloneDeep(key, map), cloneDeep(value, map));
            });
            return newMap;

        case ReferenceType.Set:
            const newSet = new Set();
            target.forEach((value: any) => {
                newSet.add(cloneDeep(value, map));
            });
            return newSet;
        
        case ReferenceType.Symbol:
            // 全局Symbol Symbol.for('key')
            const symbolKey = Symbol.keyFor(target);
            if (symbolKey) {
                return Symbol.for(symbolKey);
            }

            // 自定义Symbol Symbol('key')
            const description = target.description;
            if (description) {
                return Symbol(description);
            }

            return Symbol();

        case ReferenceType.Object || ReferenceType.Array:
            if (map?.get(target)) {
                return map.get(target);
            }

            const result: ReturnTarget = type === ReferenceType.Object ? {} : [];
            for (let key in target) {
                hasOwnProperty(target, key) && Reflect.set(result, key, cloneDeep(target[key], map));
            }
            map?.set(target, result);
            return result;

        default:
            return target;
    }
}


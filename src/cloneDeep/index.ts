/* generated by 'bin/methodTemplateGenerate.js' */
enum BasicType {
    String = 'String',
    Number = 'Number',
    Boolean = 'Boolean',
    Null = 'Null',
    Undefined = 'Undefined',
    BigInt = 'BigInt'
}

enum ReferenceType {
    // Symbol 基础类型，这里当作引用类型处理
    Symbol = 'Symbol',
    Object = 'Object',
    Array = 'Array',
    Function = 'Function',
    RegExp = 'RegExp',
    Date = 'Date',
    Map = 'Map',
    Set = 'Set',
    HtmlElement = 'HtmlElement'
}

type TMap = undefined | null | WeakMap<any, any>;
type ReturnTarget = object | any[];

function getType(target: any): string {
    return Object.prototype.toString.call(target).slice(8, -1);
}

function hasOwnProperty(target: any, key: string): boolean {
    return Object.prototype.hasOwnProperty.call(target, key);
}

function isEvalSupported(): boolean {
    try {
        eval('1 + 2');
        return true;
    } catch (err) {
        return false;
    }
}


export function cloneDeep(target: any, map: TMap = new WeakMap()): ReturnType<typeof target> {
    const type: string = getType(target);
    if (type in BasicType) {
        return target;
    }

    switch (type) {
        case ReferenceType.Date:
            return new Date(target);

        case ReferenceType.RegExp:
            return new RegExp(target.source, target.flags);

        case ReferenceType.HtmlElement:
            return target.cloneNode(true);

        case ReferenceType.Function:
            if (isEvalSupported()) {
                let newFunction: Function | null = null;
                eval(`newFunction = ${target.toString()}`);
                return newFunction;
            }
            return function() {
                target.apply(this, arguments);
            };

        case ReferenceType.Map:
            const newMap = new Map();
            target.forEach((value: any, key: any) => {
                newMap.set(cloneDeep(key, map), cloneDeep(value, map));
            });
            return newMap;

        case ReferenceType.Set:
            const newSet = new Set();
            target.forEach((value: any) => {
                newSet.add(cloneDeep(value, map));
            });
            return newSet;
        
        case ReferenceType.Symbol:
            // 全局Symbol Symbol.for('key')
            const symbolKey = Symbol.keyFor(target);
            if (symbolKey) {
                return Symbol.for(symbolKey);
            }

            // 自定义Symbol Symbol('key')
            const description = target.description;
            if (description) {
                return Symbol(description);
            }

            return Symbol();

        case ReferenceType.Object || ReferenceType.Array:
            if (map?.get(target)) {
                return map.get(target);
            }

            const result: ReturnTarget = type === ReferenceType.Object ? {} : [];
            for (let key in target) {
                hasOwnProperty(target, key) && Reflect.set(result, key, cloneDeep(target[key], map));
            }
            map?.set(target, result);
            return result;

        default:
            return target;
    }
}

